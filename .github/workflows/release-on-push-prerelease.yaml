name: release-please (prerelease on push)

on:
  push:
    branches:
      - pre/beta
      - pre/beta/*
    paths-ignore:
      - '.github/workflows/**'

permissions:
  contents: write
  pull-requests: write
  issues: write

env:
  # --- Experiments / toggles (live) ---
  # python prune behavior: files | pacman | off
  EXP_PRUNE_PYTHON_MODE: files
  # prune the large non-runtime trees (man/doc/info/locale/cache/clang)
  EXP_PRUNE_BULK: 'true'
  # run ruby runtime validation via Gtk.init (not just requires)
  EXP_VALIDATE_RUBY_GTK: 'true'

jobs:
  release:
    runs-on: ubuntu-latest
    outputs:
      release_created: ${{ steps.rp.outputs.release_created }}
      tag_name: ${{ steps.rp.outputs.tag_name }}
    steps:
      # 1) Release Please for prerelease branches
      - uses: googleapis/release-please-action@v4
        id: rp
        with:
          config-file: release-please-config.prerelease.json
          manifest-file: .release-please-manifest.json
          target-branch: ${{ github.ref_name }}
          # We create the PR elsewhere when desired; keep RP in tag/release mode for pre/*
          skip-github-pull-request: true

      # 2) Only build/upload when a new GitHub prerelease was created
      - name: Checkout repository
        if: ${{ steps.rp.outputs.release_created == 'true' }}
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # 3) Build core Lich-5 payload (same as before)
      - name: Create Core Lich-5 package
        if: ${{ steps.rp.outputs.release_created == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p Lich5 Lich5/data Lich5/scripts

          curl -fsSL https://raw.githubusercontent.com/elanthia-online/scripts/master/scripts/alias.lic         > Lich5/scripts/alias.lic
          curl -fsSL https://raw.githubusercontent.com/elanthia-online/scripts/master/scripts/autostart.lic     > Lich5/scripts/autostart.lic
          curl -fsSL https://raw.githubusercontent.com/elanthia-online/scripts/master/scripts/ewaggle.lic       > Lich5/scripts/ewaggle.lic
          curl -fsSL https://raw.githubusercontent.com/elanthia-online/scripts/master/scripts/go2.lic           > Lich5/scripts/go2.lic
          curl -fsSL https://raw.githubusercontent.com/elanthia-online/scripts/master/scripts/jinx.lic          > Lich5/scripts/jinx.lic
          curl -fsSL https://raw.githubusercontent.com/elanthia-online/scripts/master/scripts/lich5-update.lic  > Lich5/scripts/lich5-update.lic
          curl -fsSL https://raw.githubusercontent.com/elanthia-online/scripts/master/scripts/log.lic           > Lich5/scripts/log.lic
          curl -fsSL https://raw.githubusercontent.com/elanthia-online/scripts/master/scripts/map.lic           > Lich5/scripts/map.lic
          curl -fsSL https://raw.githubusercontent.com/elanthia-online/scripts/master/scripts/repository.lic    > Lich5/scripts/repository.lic
          curl -fsSL https://raw.githubusercontent.com/elanthia-online/scripts/master/scripts/vars.lic          > Lich5/scripts/vars.lic
          curl -fsSL https://raw.githubusercontent.com/elanthia-online/scripts/master/scripts/version.lic       > Lich5/scripts/version.lic
          curl -fsSL https://raw.githubusercontent.com/elanthia-online/dr-scripts/master/dependency.lic         > Lich5/scripts/dependency.lic
          curl -fsSL https://raw.githubusercontent.com/elanthia-online/scripts/master/scripts/effect-list.xml   > Lich5/data/effect-list.xml

          cp lich.rbw Lich5/
          cp -r lib Lich5/

          tar -czvf lich-5.tar.gz Lich5/
          zip -r lich-5.zip Lich5/

      - name: Upload archives to Release
        if: ${{ steps.rp.outputs.release_created == 'true' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release upload "${{ steps.rp.outputs.tag_name }}" lich-5.tar.gz lich-5.zip

  installer_gate:
    needs: release
    if: ${{ needs.release.outputs.release_created == 'true' }}
    runs-on: ubuntu-latest
    outputs:
      installer: ${{ steps.gate.outputs.installer }}
    steps:
      - name: Resolve installer gate (labels only)
        id: gate
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          want="true"

          # Find PRs associated with this commit
          prs="$(gh api -H 'Accept: application/vnd.github+json' \
                "/repos/$GITHUB_REPOSITORY/commits/$GITHUB_SHA/pulls" --jq '.[].number' || true)"

          # If any associated PR has skip/no-installer (case-insensitive), disable installer
          if [ -n "$prs" ]; then
            for pr in $prs; do
              labels="$(gh pr view "$pr" --json labels --jq '.labels[].name' || true | tr '[:upper:]' '[:lower:]')"
              if echo "$labels" | grep -Eq '^(skip-installer|no-installer)$'; then
                want="false"
              fi
            done
          fi

          echo "installer=$want" >> "$GITHUB_OUTPUT"
          echo "Resolved installer=$want"

  # 4) Build Windows installer (Ruby4Lich5.exe)
  build_installer:
    needs: [release, installer_gate]
    if: ${{ needs.release.outputs.release_created == 'true' && needs.installer_gate.outputs.installer == 'true' }}
    runs-on: windows-latest
    timeout-minutes: 120

    steps:
      - uses: actions/checkout@v4

      # Pin Ruby explicitly on windows-latest
      - name: Set up Ruby (3.4.5)
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.4.5'
          bundler-cache: false

      # Install Inno Setup
      - name: Install Inno Setup
        shell: powershell
        run: |
          choco feature disable -n=showDownloadProgress
          choco install -y --limit-output innosetup

      # Install MSYS2 directly into the app tree
      - name: Install MSYS2 into app tree
        shell: powershell
        run: |
          choco feature disable -n=showDownloadProgress
          choco install -y --limit-output msys2 --params '"/InstallDir:C:\Ruby4Lich5\msys64 /NoUpdate"'

      # Build sanitized PATH that prefers vendored MSYS2 (Option A) and cache it
      - name: Build sanitized PATH for vendored MSYS2
        id: vendormsys
        shell: powershell
        run: |
          $msys = 'C:\Ruby4Lich5\msys64'
          if (!(Test-Path $msys)) { Write-Error "Expected $msys to exist at this point"; exit 1 }
          $orig = $env:Path -split ';'
          $filtered = $orig | Where-Object {
            $_ -and
            ($_ -notlike '*\Ruby\*\x64\msys64\*') -and   # drop runner DevKit MSYS2
            ($_ -ne 'C:\mingw64\bin') -and               # drop global mingw
            ($_ -notmatch '^C:\\Strawberry(\\|$)')       # drop Strawberry toolchain
          }
          $san = @("$msys\ucrt64\bin","$msys\usr\bin") + $filtered
          $joined = ($san -join ';')
          \"PATH_VENDOR_MSYS=$joined\" | Out-File $env:GITHUB_ENV -Append -Encoding utf8
          \"RI_DEVKIT=\" | Out-File $env:GITHUB_ENV -Append -Encoding utf8
          \"path=$joined\" | Out-File $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: Initialize MSYS2 (minimal UCRT64; no meta toolchain)
        shell: powershell
        env:
          PATH: ${{ steps.vendormsys.outputs.path }}
          RI_DEVKIT: ''
        run: |
          $msys   = 'C:\Ruby4Lich5\msys64'
          $pacman = Join-Path $msys 'usr\bin\pacman.exe'
          if (!(Test-Path $pacman)) { Write-Error "pacman not found at $pacman"; exit 1 }

          $env:MSYSTEM = 'UCRT64'
          & $pacman -Sy --noconfirm
          & $pacman -S --needed --noconfirm `
            mingw-w64-ucrt-x86_64-gcc `
            mingw-w64-ucrt-x86_64-gcc-libs `
            mingw-w64-ucrt-x86_64-make `
            mingw-w64-ucrt-x86_64-pkgconf `
            mingw-w64-ucrt-x86_64-gobject-introspection `
            mingw-w64-ucrt-x86_64-sqlite3 `
            mingw-w64-ucrt-x86_64-gtk3 `
            make

      # Sanity checks: ensure vendored toolchain resolves first & libs are discoverable
      - name: Dependency validation (toolchain & pkg-config)
        shell: powershell
        env:
          PATH: ${{ steps.vendormsys.outputs.path }}
          RI_DEVKIT: ''
        run: |
          $msys = 'C:\Ruby4Lich5\msys64'
          $gcc  = Join-Path $msys 'ucrt64\bin\gcc.exe'
          $pkgc = Join-Path $msys 'ucrt64\bin\pkg-config.exe'
          $pac  = Join-Path $msys 'usr\bin\pacman.exe'
      
          if (!(Test-Path $pac))  { Write-Error "pacman not found at $pac"; exit 1 }
          if (!(Test-Path $gcc))  { Write-Error "vendored gcc not found at $gcc"; exit 1 }
          if (!(Test-Path $pkgc)) { Write-Error "vendored pkg-config not found at $pkgc"; exit 1 }
      
          # Prove the vendored tools run
          & $gcc --version | Select-Object -First 1
          if ($LASTEXITCODE -ne 0) { Write-Error "vendored gcc failed to execute"; exit 1 }
          & $pkgc --version
          if ($LASTEXITCODE -ne 0) { Write-Error "vendored pkg-config failed to execute"; exit 1 }
      
          # Prove pkg-config sees the libraries we installed
          cmd /c `"$pkgc`" --print-errors --exists gtk+-3.0
          if ($LASTEXITCODE -ne 0) { Write-Error "pkg-config cannot resolve gtk+-3.0"; exit 1 }
          cmd /c `"$pkgc`" --print-errors --exists sqlite3
          if ($LASTEXITCODE -ne 0) { Write-Error "pkg-config cannot resolve sqlite3"; exit 1 }
      
          # Python WILL be pulled in by GTK deps; we remove it later. Don't fail here.
          # Just surface whether it showed up so we can observe the behavior.
          $env:MSYSTEM = 'UCRT64'
          & $pac -Qq mingw-w64-ucrt-x86_64-python 1>$null 2>$null
          if ($LASTEXITCODE -eq 0) {
            Write-Host "Note: mingw-w64-ucrt-x86_64-python present after init (expected via GTK deps); will remove later."
          }
      
          # Pin tool choices for downstream (regardless of PATH order)
          "CC=$gcc"                  | Out-File $env:GITHUB_ENV -Append -Encoding utf8
          "PKG_CONFIG=$pkgc"         | Out-File $env:GITHUB_ENV -Append -Encoding utf8
          # Helpful for Ruby native gems that honor these
          "PKG_CONFIG_PATH=$($msys)\ucrt64\lib\pkgconfig;$($msys)\lib\pkgconfig" | Out-File $env:GITHUB_ENV -Append -Encoding utf8

      # Install required gems (pruned list)
      - name: Install required gems
        shell: powershell
        env:
          PATH: ${{ steps.vendormsys.outputs.path }}
          RI_DEVKIT: ''
          CC: gcc
          PKG_CONFIG: pkg-config
        run: |
          gem install sqlite3 --platform ruby -- --enable-system-libraries --with-sqlite3-include=${env:MSYS2_ROOT}/ucrt64/include --with-sqlite3-lib=${env:MSYS2_ROOT}/ucrt64/lib
          gem install ascii_charts gtk3 json logger os ostruct redis sequel terminal-table tzinfo tzinfo-data webrick --no-document
          gem uninstall rexml --force
          gem install rexml --version 3.3.1

      # Optional experiment: validate Ruby actually initializes GTK (not just require)
      - name: Validate Ruby GTK/sqlite3 runtime
        if: ${{ env.EXP_VALIDATE_RUBY_GTK == 'true' }}
        shell: powershell
        env:
          PATH: ${{ steps.vendormsys.outputs.path }}
          RI_DEVKIT: ''
        run: |
          $msys = 'C:\Ruby4Lich5\msys64'
          # Prepend vendored MSYS; keep the rest so ruby.exe is still found
          $env:Path = "$msys\ucrt64\bin;$msys\usr\bin;$env:Path"
      
          # Resolve ruby.exe from PATH (hostedtoolcache)
          $rubyExe = (& "$env:SystemRoot\System32\where.exe" ruby 2>$null | Select-Object -First 1)
          if (-not $rubyExe) { Write-Error "ruby.exe not found on PATH"; exit 1 }
      
          # Prove vendored tools win
          $gccFirst = @(& "$env:SystemRoot\System32\where.exe" gcc 2>$null)[0]
          $pcFirst  = @(& "$env:SystemRoot\System32\where.exe" pkg-config 2>$null)[0]
          if (-not $gccFirst -or -not $pcFirst) { Write-Error "Missing gcc/pkg-config"; exit 1 }
          if (-not $gccFirst.StartsWith('C:\Ruby4Lich5\msys64', 'OrdinalIgnoreCase')) { Write-Error "gcc resolves to non-vendored: $gccFirst"; exit 1 }
          if (-not $pcFirst.StartsWith('C:\Ruby4Lich5\msys64', 'OrdinalIgnoreCase')) { Write-Error "pkg-config resolves to non-vendored: $pcFirst"; exit 1 }
      
          # pkg-config sanity
          cmd /c pkg-config --print-errors --exists gtk+-3.0
          if ($LASTEXITCODE -ne 0) { Write-Error "pkg-config cannot resolve gtk+-3.0"; exit 1 }
          cmd /c pkg-config --print-errors --exists sqlite3
          if ($LASTEXITCODE -ne 0) { Write-Error "pkg-config cannot resolve sqlite3"; exit 1 }
      
          # IMPORTANT: correct Ruby code, correct quoting
          #  - constant is Gtk (not GTK)
          #  - keep quotes around string literals
          #  - pass an empty ARGV to Gtk.init to avoid surprises
          $rb = 'require "gtk3"; require "sqlite3"; puts "ruby=#{RUBY_VERSION}"; Gtk.init([]); puts "GTK.init OK"'
          #  Use the Stop Parsing Operator ( --% ) for PowerShell to avoid interpolation in the string above
          & $rubyExe -e --% $rb
          if ($LASTEXITCODE -ne 0) { Write-Error "Ruby GTK3/sqlite3 load failed"; exit 1 }

      # (Optional) Remove Python to keep the bundle lean. Mode is driven by EXP_PRUNE_PYTHON_MODE:
      #   - 'files'  : delete python binaries/trees by glob (default)
      #   - 'pacman' : uninstall python packages via pacman, then also run the files sweep
      #   - 'off'    : skip this step entirely (use the job/step-level if: to skip)
      - name: Prune Python from bundled MSYS2 (mode=${{ env.EXP_PRUNE_PYTHON_MODE || 'files' }})
        if: ${{ env.EXP_PRUNE_PYTHON_MODE != 'off' }}
        shell: powershell
        env:
          EXP_PRUNE_PYTHON_MODE: ${{ env.EXP_PRUNE_PYTHON_MODE }}
        run: |
          $msys   = 'C:\Ruby4Lich5\msys64'
          if (!(Test-Path $msys)) { Write-Host "No MSYS2 at $msys; skipping."; exit 0 }

          # Report size BEFORE
          $beforeMB = [math]::Round((Get-ChildItem -Recurse $msys | Measure-Object Length -Sum).Sum / 1MB)
          Write-Host "Python-prune: before = $beforeMB MB"

          $mode   = "${env:EXP_PRUNE_PYTHON_MODE}"; if (-not $mode) { $mode = 'files' }
          $pacman = Join-Path $msys 'usr\bin\pacman.exe'

          if ($mode -eq 'pacman' -and (Test-Path $pacman)) {
            $env:MSYSTEM = 'UCRT64'
            $installed = & $pacman -Qq 2>$null; if ($LASTEXITCODE -ne 0) { $installed = @() }
            $pattern   = '^(python($|[0-9]))|(mingw-w64-(ucrt-)?x86_64-python.*)$'
            $py = @($installed | Where-Object { $_ -match $pattern })
            if ($py.Count -gt 0) {
              Write-Host "pacman removing: $($py -join ' ')"
              & $pacman -Rns --noconfirm @py 1>$null 2>$null
              if ($LASTEXITCODE -ne 0) {
                Write-Warning "pacman -Rns failed; retrying -Rdd"
                & $pacman -Rdd --noconfirm @py 1>$null 2>$null
              }
            } else {
              Write-Host "pacman: no python packages installed"
            }
            # fall through to files sweep for belt-and-suspenders
          } else {
            Write-Host "pacman phase skipped (mode='$mode' or pacman missing); doing files sweep"
          }

          # Files sweep (runs for mode=files and mode=pacman)
          $targets = @(
            "$msys\ucrt64\bin\python*.exe",
            "$msys\ucrt64\lib\python*",
            "$msys\mingw64\bin\python*.exe",
            "$msys\mingw64\lib\python*",
            "$msys\usr\bin\python*.exe",
            "$msys\usr\lib\python*"
          )
          $removed = 0
          foreach ($g in $targets) {
            Get-ChildItem -Path $g -Recurse -Force -ErrorAction SilentlyContinue | ForEach-Object {
              Remove-Item -Recurse -Force -ErrorAction SilentlyContinue $_.FullName
              $removed++
            }
          }
          Write-Host "files sweep removed ≈ $removed paths"

          # Report size AFTER
          $afterMB = [math]::Round((Get-ChildItem -Recurse $msys | Measure-Object Length -Sum).Sum / 1MB)
          $savedMB = [math]::Max(0, $beforeMB - $afterMB)
          Write-Host "Python-prune: after  = $afterMB MB (saved $savedMB MB)"

      # Bulk prune of MSYS non-runtime trees (report size delta)
      - name: Bulk prune non-runtime trees (report delta)
        if: ${{ env.EXP_PRUNE_BULK == 'true' }}
        shell: powershell
        env:
          PATH: ${{ steps.vendormsys.outputs.path }}
          RI_DEVKIT: ''
        run: |
          $msys = 'C:\Ruby4Lich5\msys64'
          Write-Host "::group::MSYS2 size report & prune"
          # Report size BEFORE
          $beforeMB = [math]::Round((Get-ChildItem -Recurse $msys | Measure-Object Length -Sum).Sum / 1MB)
          Write-Host "MSYS2-prune: before = $beforeMB MB"

          $paths = @(
            Join-Path $msys 'var\cache\pacman\pkg'
            Join-Path $msys 'usr\share\man'
            Join-Path $msys 'usr\share\doc'
            Join-Path $msys 'usr\share\info'
            Join-Path $msys 'usr\share\locale'
            Join-Path $msys 'usr\lib\clang'
          )
          foreach ($p in $paths) {
            if (Test-Path $p) {
              Write-Host "Removing $p ..."
              Remove-Item $p -Recurse -Force -ErrorAction SilentlyContinue
            } else {
              Write-Host "Skip (not present): $p"
            }
          }

          # Report size AFTER
          $afterMB = [math]::Round((Get-ChildItem -Recurse $msys | Measure-Object Length -Sum).Sum / 1MB)
          $savedMB = [math]::Max(0, $beforeMB - $afterMB)
          Write-Host "MSYS2-prune: after  = $afterMB MB (saved $savedMB MB)"
          Write-Host "::endgroup::"

      
      # Pull the packaged Lich payload from the just-created Release
      - name: Download core Lich payload from the Release
        if: ${{ needs.release.outputs.release_created == 'true' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          gh release download "${{ needs.release.outputs.tag_name }}" -p 'lich-5.zip'
          unzip -q lich-5.zip
          # Archive contains Lich5/ (capital L) to match the .iss Source paths

      # Build Windows installer with Inno Setup
      - name: Build Windows installer with Inno Setup
        shell: powershell
        env:
          PATH: ${{ steps.vendormsys.outputs.path }}
          RI_DEVKIT: ''
        run: |
          $iscc = "${env:ProgramFiles(x86)}\Inno Setup 6\ISCC.exe"
          if (!(Test-Path $iscc)) { Write-Error "ISCC.exe not found at $iscc"; exit 1 }
          & $iscc "R4LGTK3.iss"
          if (!(Test-Path .\Output\Ruby4Lich5.exe)) { Write-Error "Expected Output\Ruby4Lich5.exe not found"; exit 1 }
          Move-Item -Path .\Output\Ruby4Lich5.exe -Destination .\Ruby4Lich5.exe -Force

      - name: Upload installer to Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          gh release upload "${{ needs.release.outputs.tag_name }}" Ruby4Lich5.exe
