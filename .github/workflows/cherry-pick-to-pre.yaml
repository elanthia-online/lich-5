name: Curate Pre Branch (Cherry-pick PRs)
# Purpose: curate a prerelease branch (e.g., pre/beta or pre/beta/<slug>) from a clean base,
#          then cherry-pick or squash-merge selected PRs for prerelease testing.
# Footguns guarded here:
#   - Targeting main (blocked).
#   - Using a base other than main (blocked).
#   - Non-pre/beta destinations (normalized/blocked).
#   - Unsafe destination names (../ or whitespace) (blocked).
#   - History reset is opt-in via reset_destination=true (destroys existing dest history).
# Inputs overview:
#   - prs: comma-separated PR numbers (digits only).
#   - mode: auto (prefer merge commit if merged), merged (force merge commit), head (use PR head).
#   - squash: true to squash PR heads to one commit; false preserves commit history.
#   - conflict_strategy: abort (default), ours, theirs, both (union-merge both sides).

on:
  workflow_dispatch:
    inputs:
      dest:
        description: "Destination prerelease branch (e.g., pre/beta)"
        required: true
        default: "pre/beta"
      base:
        description: "Base branch to start from"
        required: true
        default: "main"
      prs:
        description: "Comma-separated PR numbers to include (e.g., 12,27,43)"
        required: true
      mode:
        description: "auto | merged | head (how to source commits)"
        required: true
        default: "auto"
      squash:
        description: "Squash multi-commit PRs into one commit on the pre branch? (true/false)"
        required: true
        default: "true"
      conflict_strategy:
        description: "abort | ours | theirs | both"
        required: true
        default: "abort"
      reset_destination:
        description: "Reset destination history to base before curating (destroys history)"
        required: true
        default: "false"

permissions:
  contents: write
  pull-requests: read

jobs:
  curate:
    runs-on: ubuntu-latest
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0 pinned
        with:
          fetch-depth: 0

      - name: Guard validate destination and base
        shell: bash
        run: |
          set -euo pipefail
          BASE="${{ inputs.base }}"
          DEST="${{ inputs.dest }}"
          if [ "$BASE" != "main" ]; then
            echo "::error::Only 'main' is allowed as base in production."
            exit 1
          fi
          if [[ ! "$DEST" =~ ^pre/beta(/[-a-z0-9_.]+)?$ ]]; then
            echo "::error::Destination must be pre/beta or pre/beta/<slug>."
            exit 1
          fi

      - name: Guard validate PR list
        shell: bash
        run: |
          set -euo pipefail
          if ! echo "${{ inputs.prs }}" | grep -Eq '^[0-9]+(,[0-9]+)*$'; then
            echo "::error::prs must be comma-separated integers."
            exit 1
          fi

      - name: Ensure jq is available
        shell: bash
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

      - name: Configure bot identity
        shell: bash
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Initialize conflict tracking
        shell: bash
        run: |
          echo "CONFLICT_LOG_FILE=$(mktemp)" >> "$GITHUB_ENV"
          echo "HAD_CONFLICTS=false" >> "$GITHUB_ENV"

      # Install the union resolver helper (action-based; DRY)
      - name: Install union resolver helper
        uses: ./.github/actions/install-union-resolver

      - name: Prepare destination branch
        shell: bash
        env:
          BASE: ${{ inputs.base }}
          DEST: ${{ inputs.dest }}
          STRAT: ${{ inputs.conflict_strategy }}
          RESET: ${{ inputs.reset_destination }}
        run: |
          set -euo pipefail
          git fetch origin "$BASE"
          if [ "$RESET" = "true" ]; then
            git checkout -B "$DEST" "origin/$BASE"
          else
            if git ls-remote --exit-code --heads origin "$DEST" >/dev/null 2>&1; then
              git fetch origin "$DEST"
              git checkout "$DEST"
              # Preserve train ancestry: try a no-ff merge; if it conflicts, report and continue
              git merge --no-ff --no-edit "origin/$BASE" || {
                conflicts="$(git diff --name-only --diff-filter=U || true)"
                echo "::group::Merge conflicts while merging origin/$BASE into $DEST"
                if [ -n "$conflicts" ]; then
                  # Emit one warning per conflicted file
                  while IFS= read -r f; do
                    [ -n "$f" ] && echo "::warning file=$f::merge conflict in $f"
                  done <<< "$conflicts"
                  {
                    echo "### Merge conflicts detected while syncing \`$DEST\` with \`origin/$BASE\`"
                    printf '%s' "$conflicts" | awk '{print "- " $0}'
                  } >> "$GITHUB_STEP_SUMMARY"
                else
                  echo "::warning::Merge failed but no conflicted files were detected."
                fi
                if [ "$STRAT" = "both" ] && [ -n "$conflicts" ]; then
                  # Source helper and resolve both sides; keep original logging strings
                  . "$UNION_RESOLVE_HELPER"
                  resolve_conflicts_both "Base Sync Conflict Resolution (Union Merge)" "**Operation:** Syncing \`$DEST\` with \`origin/$BASE\`" "$CONFLICT_LOG_FILE"
                  git commit -m "chore: sync base (union merge via workflow)"
                  echo "::endgroup::"
                else
                  git merge --abort || true
                  echo "::endgroup::"
                  exit 1
                fi
              }
            else
              git checkout -B "$DEST" "origin/$BASE"
            fi
          fi

      - name: Create prerelease base tag
        shell: bash
        env:
          DEST: ${{ inputs.dest }}
          BASE: ${{ inputs.base }}
        run: |
          set -euo pipefail
          BASE_SHA="$(git rev-parse "origin/$BASE")"
          TAG="prebeta-base/${DEST}"
          git tag -f "$TAG" "$BASE_SHA"
          git push -f origin "refs/tags/$TAG"

      - name: Cherry-pick PRs (no gh CLI; use PR title for squash message)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          DEST: ${{ inputs.dest }}
          MODE: ${{ inputs.mode }}
          SQUASH: ${{ inputs.squash }}
          STRAT: ${{ inputs.conflict_strategy }}
        shell: bash
        run: |
          set -euo pipefail
          trap 'echo "::error::Cherry-pick failed. Aborting partial operations."; (git cherry-pick --abort || true); (git merge --abort || true); exit 1' ERR

          # Strategy mapping
          case "$STRAT" in
            ours)   XFLAG="-X ours" ;;
            theirs) XFLAG="-X theirs" ;;
            both)   XFLAG="" ;;
            *)      XFLAG="" ;;
          esac

          api() { curl -sS -H "Authorization: Bearer $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" "$@"; }
          with_pr_trailer() {
            local title="$1" num="$2"
            echo "${title} (#${num})"
          }

          # Source helper for 'both' strategy resolution
          . "$UNION_RESOLVE_HELPER"

          # Run a command with conflict resolution; if it fails, resolve and optionally continue
          run_with_conflict_resolution() {
            local pr_context="$1"
            local continue_cmd="$2"
            shift 2
            set +e
            "$@"
            local st=$?
            set -e
            if [ $st -ne 0 ]; then
              if [ "$STRAT" = "both" ]; then
                resolve_conflicts_both "PR #$pr_context - Conflict Resolution (Union Merge)" "" "$CONFLICT_LOG_FILE"
                if [ -n "$continue_cmd" ]; then
                  eval "$continue_cmd"
                fi
              else
                return $st
              fi
            fi
          }

          # Iterate PRs
          IFS=, read -r -a pr_list <<< "${{ inputs.prs }}"
          for N in "${pr_list[@]}"; do
            N=$(echo "$N" | xargs)
            echo "::group::PR #$N"
            PR_JSON=$(api "https://api.github.com/repos/$REPO/pulls/$N")
            STATE=$(echo "$PR_JSON"     | jq -r '.state')
            MERGED=$(echo "$PR_JSON"    | jq -r '.merged')
            MERGE_SHA=$(echo "$PR_JSON" | jq -r '.merge_commit_sha')
            TITLE=$(echo "$PR_JSON"     | jq -r '.title')
            SUBJECT=$(with_pr_trailer "$TITLE" "$N")

            if [ "$MODE" = "merged" ] || { [ "$MODE" = "auto" ] && [ "$MERGED" = "true" ] && [ "$MERGE_SHA" != "null" ]; }; then
              echo "Cherry-picking MERGED PR #$N commit $MERGE_SHA"
              run_with_conflict_resolution "$N" "git cherry-pick --continue" git cherry-pick -x $XFLAG "$MERGE_SHA"
              BODY="$(git log -1 --pretty=%b HEAD || true)"
              if [ -n "$BODY" ]; then
                git commit --amend -m "$SUBJECT" -m "$BODY"
              else
                git commit --amend -m "$SUBJECT"
              fi
            else
              echo "Fetching PR head for #$N"
              git fetch origin "pull/$N/head:pr-$N"
              if [ "$SQUASH" = "true" ]; then
                echo "  - Squashing with templated commit subject (PR title + trailer)"
                run_with_conflict_resolution "$N" "git commit -m "$SUBJECT"" git merge --squash $XFLAG "pr-$N"
              else
                echo "  - Cherry-picking each commit (preserving history)"
                for C in $(git rev-list --reverse --no-merges ^HEAD "pr-$N"); do
                  run_with_conflict_resolution "$N" "git cherry-pick --continue" git cherry-pick -x $XFLAG "$C"
                done
              fi
              git branch -D "pr-$N" || true
            fi
            echo "::endgroup::"
          done

      - name: Push destination branch
        shell: bash
        run: |
          git push origin HEAD:"${{ inputs.dest }}"

      - name: Report conflict resolutions
        if: env.HAD_CONFLICTS == 'true'
        shell: bash
        run: |
          echo "## Conflict union resolutions" >> "$GITHUB_STEP_SUMMARY"
          cat "$CONFLICT_LOG_FILE" >> "$GITHUB_STEP_SUMMARY"

      - name: Summary
        shell: bash
        run: |
          echo "Curated ${{ inputs.dest }} from ${{ inputs.base }} with PRs: ${{ inputs.prs }}"
