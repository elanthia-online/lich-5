name: Prepare Pre-release

on:
  workflow_dispatch:
    inputs:
      target_branch:
        description: "Branch to prepare prerelease from"
        required: true
        default: "pre/beta"
      base_branch:                           # NEW: declare your trunk
        description: "Base branch for prerelease"
        required: true
        default: "main"
      seed_beta_zero:
        description: "Force the first prerelease to end in .0 (e.g., 5.13.0-beta.0)"
        type: boolean
        default: true

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  prepare:
    runs-on: ubuntu-latest
    steps:
      - name: Guard validate target and base
        id: guard_validate
        shell: bash
        env:
          RAW_TARGET: ${{ inputs.target_branch }}
          RAW_BASE:   ${{ inputs.base_branch }}
        run: |
          set -euo pipefail
          die(){ echo "::error::$*"; exit 1; }
          norm(){ local s="$1"; s="${s#refs/heads/}"; s="$(echo "$s" | tr -d '[:space:]')"; s="${s%/}"; echo "$s"; }
      
          TARGET="$(norm "$RAW_TARGET")"
          BASE="$(norm "$RAW_BASE")"
      
          case "$BASE" in
            main) ;;
            *) die "Invalid base '$BASE'. Only 'main' is allowed for prerelease preparation." ;;
          esac
      
          if [[ "$TARGET" =~ (\.\.|[[:space:]]) ]]; then
            die "Target '$TARGET' contains illegal sequences."
          fi
      
          if [[ "$TARGET" != pre/beta && "$TARGET" != pre/beta/* ]]; then
            if [[ "$TARGET" =~ ^[A-Za-z0-9._-]+(/[A-Za-z0-9._-]+)*$ ]]; then
              echo "Shaping '$TARGET' => 'pre/beta/$TARGET'"
              TARGET="pre/beta/$TARGET"
            else
              die "Target '$TARGET' must be 'pre/beta' or 'pre/beta/<slug>'."
            fi
          fi
      
            printf 'TARGET_SAFE=%s\n' "$TARGET" >> "$GITHUB_ENV"
            printf 'BASE_SAFE=%s\n'   "$BASE"   >> "$GITHUB_ENV"
            printf 'target_safe=%s\n' "$TARGET" >> "$GITHUB_OUTPUT"
            printf 'base_safe=%s\n'   "$BASE"   >> "$GITHUB_OUTPUT"


      - name: Checkout prerelease branch
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          ref: ${{ steps.guard_validate.outputs.target_safe }}
          fetch-depth: 0

      - name: Derive prerelease anchor sha
        id: derive_anchor
        shell: bash
        env:
          TARGET_SAFE: ${{ steps.guard_validate.outputs.target_safe }}
        run: |
          set -euo pipefail
          git fetch --tags origin
          if git rev-parse -q --verify "refs/tags/prebeta-base/${TARGET_SAFE}" >/dev/null; then
            ANCHOR_SHA=$(git rev-parse "refs/tags/prebeta-base/${TARGET_SAFE}")
            echo "Using tag anchor: $ANCHOR_SHA"
          else
            echo "Tag not found; falling back to merge-base with origin/main"
            git fetch origin main
            ANCHOR_SHA=$(git merge-base "origin/${TARGET_SAFE}" origin/main)
            echo "Fallback anchor: $ANCHOR_SHA"
          fi
          printf 'anchor_sha=%s\n' "$ANCHOR_SHA" >> "$GITHUB_OUTPUT"

      - name: Git LF config (stabilize EOL)
        run: |
          git config --global core.autocrlf false
          git config --global core.eol lf

      # Ensure the prerelease target branch exists; create it from base if missing
      - name: Ensure target prerelease branch exists (create from base if missing)
        shell: bash
        run: |
          set -euo pipefail
          TARGET="${{ inputs.target_branch }}"
          BASE="origin/${{ inputs.base_branch }}"
      
          # Fetch base and remote target without mapping into local names
          git fetch --prune --tags --force origin "${{ inputs.base_branch }}" "$TARGET" || true
      
          CURRENT=$(git rev-parse --abbrev-ref HEAD || echo "")
          echo "Current branch: ${CURRENT}"
      
          if git ls-remote --exit-code --heads origin "$TARGET" >/dev/null 2>&1; then
            echo "Remote branch $TARGET exists"
            if git show-ref --verify --quiet "refs/heads/$TARGET"; then
              echo "Local branch $TARGET exists"
              # Stay on it if already checked out; do NOT fetch into it
              if [ "$CURRENT" != "$TARGET" ]; then
                git checkout "$TARGET"
              fi
              # Option A: do not realign; leave as-is
            else
              echo "Creating local $TARGET to track origin/$TARGET"
              git checkout -b "$TARGET" --track "origin/$TARGET"
            fi
          else
            echo "Remote branch $TARGET does not exist; creating from base $BASE"
            git checkout -b "$TARGET" "$BASE"
            git push -u origin "$TARGET"
          fi

      # This step should be unnecessary but may be useful in diagnostics so keeping as comment
      # - name: Fetch tags
      #   run: git fetch --tags --force

      # Seed a Release-As footer ONLY for the first prerelease on this branch
      - name: Seed Release-As for initial beta.0 (first run only)
        if: ${{ inputs.seed_beta_zero }}
        shell: bash
        run: |
          set -euo pipefail

          # Only skip seeding if a beta tag exists *after* the prerelease anchor (this cycle).
          ANCHOR="${{ steps.derive_anchor.outputs.anchor_sha }}"
          has_beta_after_anchor="false"
          while IFS= read -r t; do
            [ -z "$t" ] && continue
            tsha=$(git rev-list -n1 "$t" || true)
            # Tag commit must be reachable from HEAD, but NOT from the anchor
            if git merge-base --is-ancestor "$tsha" HEAD \
               && ! git merge-base --is-ancestor "$tsha" "$ANCHOR"; then
              has_beta_after_anchor="true"
              echo "Found beta tag after anchor: $t ($tsha)"
              break
            fi
          done < <(git tag --list 'v*-beta*' --merged HEAD | sort -V)
          if [ "$has_beta_after_anchor" = "true" ]; then
            echo "Beta tags exist after anchor; not forcing .0"
            exit 0
          fi

          # Read current version from the single-package manifest (".")
          if [[ ! -f .release-please-manifest.json ]]; then
            echo ".release-please-manifest.json not found"
            exit 1
          fi

          CURR=$(jq -r '."."' .release-please-manifest.json)
          if [[ -z "$CURR" || "$CURR" == "null" ]]; then
            echo "Could not read current version from .release-please-manifest.json"
            exit 1
          fi

          IFS='.' read -r MA MI PA <<<"$CURR"
          NEXT="${MA}.$((MI+1)).0-beta.0"
          echo "Seeding Release-As: v$NEXT"

          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git commit --allow-empty -m "chore: seed prerelease ${NEXT}" -m "Release-As: v${NEXT}"
          git push origin HEAD:${{ inputs.target_branch }}

      # Sanity-check that GITHUB_TOKEN can write (labels API) in this context
      - name: GITHUB_TOKEN write self-test (labels)
        if: always()
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          repo="${{ github.repository }}"
          lbl="rp-selftest-${{ github.run_id }}"
          echo "::group::Create test label"
          gh api -X POST "/repos/$repo/labels" \
            -f name="$lbl" -f color=ededed -f description="release-please token self-test"
          echo "::endgroup::"
          echo "::group::Delete test label"
          gh api -X DELETE "/repos/$repo/labels/$lbl"
          echo "::endgroup::"
      - name: Write last-release-sha into prerelease config
        shell: bash
        env:
          ANCHOR_SHA: ${{ steps.derive_anchor.outputs.anchor_sha }}
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then
            echo "::error::'jq' is required but not found on the runner"; exit 1
          fi
          CFG="release-please-config.prerelease.json"
          if [ ! -f "$CFG" ]; then
            echo "::error::Config file '$CFG' not found on branch"; exit 1
          fi
          tmp=$(mktemp)
          jq --arg sha "$ANCHOR_SHA" '. + { "last-release-sha": $sha }' "$CFG" > "$tmp"
          mv "$tmp" "$CFG"
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add "$CFG"
          git commit -m "chore(${{ steps.guard_validate.outputs.target_safe }}): set prerelease anchor $ANCHOR_SHA" || true
          git push

      - name: Release Please (prerelease)
        uses: googleapis/release-please-action@c2a5a2bd6a758a0937f1ddb1e8950609867ed15c # v4.3.0
        id: rp
        with:
          config-file: release-please-config.prerelease.json
          manifest-file: .release-please-manifest.json
          target-branch: ${{ steps.guard_validate.outputs.target_safe }} # allow input, but default is pre/beta
          skip-github-pull-request: false    # you want the PR
          skip-github-release: true           # <-- prevent create-a-release here

      # Clean up the Release Please PR body:
      #  - keep PR numbers as plain "(#123)"
      #  - strip commit SHA links "( [abc1234](...) )"
      #  - remove PR hyperlink wrappers, keeping "(#123)"
      #  - ensure the standard footer is appended exactly once
      - name: Normalize Release Please PR body (strip SHAs/links, keep PR #, append footer)
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          OWNER: ${{ github.repository_owner }}
          TARGET_SAFE: ${{ steps.guard_validate.outputs.target_safe }}
          BASE_SAFE:   ${{ steps.guard_validate.outputs.base_safe }}
        run: |
          set -euo pipefail

          footer=$'**For additional usage/install instructions, please visit one of the following:**\n\n**DragonRealms -** https://github.com/elanthia-online/lich-5/wiki/Documentation-for-Installing-and-Upgrading-Lich\n**Gemstone IV -** https://gswiki.play.net/Lich:Software/Installation'

          # Find the Release Please PR for this prerelease branch
          # Prefer exact head/base match (open PR from TARGET_SAFE into BASE_SAFE)
          enc_head="$(printf '%s:%s' "$OWNER" "$TARGET_SAFE" | jq -sRr @uri)"
          enc_base="$(printf '%s' "$BASE_SAFE" | jq -sRr @uri)"
          prs_json="$(gh api "/repos/$REPO/pulls?state=open&head=$enc_head&base=$enc_base&per_page=10")"
          pr_number="$(printf '%s' "$prs_json" | jq -r '.[0].number // empty')"
          if [ -z "${pr_number:-}" ]; then
            echo "No open PR found for head=$OWNER:$TARGET_SAFE base=$BASE_SAFE; nothing to normalize."
            exit 0
          fi

          tmp_in="$(mktemp)"
          tmp_out="$(mktemp)"
          gh api "/repos/$REPO/pulls/$pr_number" --jq '.body' > "$tmp_in"

          # 1) Remove commit SHA link tail patterns:
          #    e.g. " ([abc1234](https://.../commit/abc1234))"  or  " ([abcdef...](...))"
          sed -E 's/ *(\(\[[0-9a-f]{7,40}\]\([^)]+\)\))//g' "$tmp_in" > "$tmp_out" && mv "$tmp_out" "$tmp_in"

          # 2) Convert PR links "([#123](https://.../pull/123))" -> "(#123)"
          sed -E 's/\(\[#([0-9]+)\]\([^)]+\)\)/(#\1)/g' "$tmp_in" > "$tmp_out" && mv "$tmp_out" "$tmp_in"

          # 3) Normalize any stray PR Markdown links like "[#123](.../pull/123)" -> "#123"
          sed -E 's/\[#([0-9]+)\]\([^)]+\)/#\1/g' "$tmp_in" > "$tmp_out" && mv "$tmp_out" "$tmp_in"

          # 4) (Safety) Remove any remaining *commit* markdown links that escaped step 1
          sed -E 's/\[[0-9a-f]{7,40}\]\([^)]+\)//g' "$tmp_in" > "$tmp_out" && mv "$tmp_out" "$tmp_in"

          # 5) Ensure footer is present exactly once (append if missing)
          if ! grep -Fq '**For additional usage/install instructions' "$tmp_in"; then
            printf '\n\n%s\n' "$footer" >> "$tmp_in"
          fi

          # Update the PR body
          gh pr edit "$pr_number" --repo "$REPO" --body-file "$tmp_in"

          echo "Release Please PR #$pr_number body normalized."
                # <-- prevent create-a-release here
