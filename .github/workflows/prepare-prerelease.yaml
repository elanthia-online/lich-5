name: Prepare Pre-release

on:
  workflow_dispatch:
    inputs:
      target_branch:
        description: "Branch to prepare prerelease from"
        required: true
        default: "pre/beta"
      base_branch:                           # NEW: declare your trunk
        description: "Base branch for prerelease"
        required: true
        default: "main"
      seed_beta_zero:
        description: "Force the first prerelease to end in .0 (e.g., 5.13.0-beta.0)"
        type: boolean
        default: true

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  prepare:
    runs-on: ubuntu-latest
    steps:
      - name: Guard validate target and base
        id: guard_validate
        shell: bash
        env:
          RAW_TARGET: ${{ inputs.target_branch }}
          RAW_BASE:   ${{ inputs.base_branch }}
        run: |
          set -euo pipefail
          die(){ echo "::error::$*"; exit 1; }
          norm(){ local s="$1"; s="${s#refs/heads/}"; s="$(echo "$s" | tr -d '[:space:]')"; s="${s%/}"; echo "$s"; }
      
          TARGET="$(norm "$RAW_TARGET")"
          BASE="$(norm "$RAW_BASE")"
      
          case "$BASE" in
            main) ;;
            *) die "Invalid base '$BASE'. Only 'main' is allowed for prerelease preparation." ;;
          esac
      
          if [[ "$TARGET" =~ (\.\.|[[:space:]]) ]]; then
            die "Target '$TARGET' contains illegal sequences."
          fi
      
          if [[ "$TARGET" != pre/beta && "$TARGET" != pre/beta/* ]]; then
            if [[ "$TARGET" =~ ^[A-Za-z0-9._-]+(/[A-Za-z0-9._-]+)*$ ]]; then
              echo "Shaping '$TARGET' => 'pre/beta/$TARGET'"
              TARGET="pre/beta/$TARGET"
            else
              die "Target '$TARGET' must be 'pre/beta' or 'pre/beta/<slug>'."
            fi
          fi
      
            printf 'TARGET_SAFE=%s\n' "$TARGET" >> "$GITHUB_ENV"
            printf 'BASE_SAFE=%s\n'   "$BASE"   >> "$GITHUB_ENV"
            printf 'target_safe=%s\n' "$TARGET" >> "$GITHUB_OUTPUT"
            printf 'base_safe=%s\n'   "$BASE"   >> "$GITHUB_OUTPUT"


      - name: Checkout prerelease branch
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          ref: ${{ steps.guard_validate.outputs.target_safe }}
          fetch-depth: 0

      - name: Derive prerelease anchor sha
        id: derive_anchor
        shell: bash
        env:
          TARGET_SAFE: ${{ steps.guard_validate.outputs.target_safe }}
        run: |
          set -euo pipefail
          git fetch --tags origin
          if git rev-parse -q --verify "refs/tags/prebeta-base/${TARGET_SAFE}" >/dev/null; then
            ANCHOR_SHA=$(git rev-parse "refs/tags/prebeta-base/${TARGET_SAFE}")
            echo "Using tag anchor: $ANCHOR_SHA"
          else
            echo "Tag not found; falling back to merge-base with origin/main"
            git fetch origin main
            ANCHOR_SHA=$(git merge-base "origin/${TARGET_SAFE}" origin/main)
            echo "Fallback anchor: $ANCHOR_SHA"
          fi
          printf 'anchor_sha=%s\n' "$ANCHOR_SHA" >> "$GITHUB_OUTPUT"

      - name: Git LF config (stabilize EOL)
        run: |
          git config --global core.autocrlf false
          git config --global core.eol lf

      # Ensure the prerelease target branch exists; create it from base if missing
      - name: Ensure target prerelease branch exists (create from base if missing)
        shell: bash
        run: |
          set -euo pipefail
          TARGET="${{ inputs.target_branch }}"
          BASE="origin/${{ inputs.base_branch }}"
      
          # Fetch base and remote target without mapping into local names
          git fetch --prune --tags --force origin "${{ inputs.base_branch }}" "$TARGET" || true
      
          CURRENT=$(git rev-parse --abbrev-ref HEAD || echo "")
          echo "Current branch: ${CURRENT}"
      
          if git ls-remote --exit-code --heads origin "$TARGET" >/dev/null 2>&1; then
            echo "Remote branch $TARGET exists"
            if git show-ref --verify --quiet "refs/heads/$TARGET"; then
              echo "Local branch $TARGET exists"
              # Stay on it if already checked out; do NOT fetch into it
              if [ "$CURRENT" != "$TARGET" ]; then
                git checkout "$TARGET"
              fi
              # Option A: do not realign; leave as-is
            else
              echo "Creating local $TARGET to track origin/$TARGET"
              git checkout -b "$TARGET" --track "origin/$TARGET"
            fi
          else
            echo "Remote branch $TARGET does not exist; creating from base $BASE"
            git checkout -b "$TARGET" "$BASE"
            git push -u origin "$TARGET"
          fi

      # This step should be unnecessary but may be useful in diagnostics so keeping as comment
      # - name: Fetch tags
      #   run: git fetch --tags --force

      # Seed a Release-As footer ONLY for the first prerelease on this branch
      - name: Seed Release-As for initial beta.0 (first run only)
        if: ${{ inputs.seed_beta_zero }}
        shell: bash
        run: |
          set -euo pipefail

          # If any beta tag is already reachable from this branch, do nothing
          if git tag --list 'v*-beta*' --merged HEAD | grep -q .; then
            echo "Found existing beta tags merged into this branch; not forcing .0"
            exit 0
          fi

          # Read current version from the single-package manifest (".")
          if [[ ! -f .release-please-manifest.json ]]; then
            echo ".release-please-manifest.json not found"
            exit 1
          fi

          CURR=$(jq -r '."."' .release-please-manifest.json)
          if [[ -z "$CURR" || "$CURR" == "null" ]]; then
            echo "Could not read current version from .release-please-manifest.json"
            exit 1
          fi

          IFS='.' read -r MA MI PA <<<"$CURR"
          NEXT="${MA}.$((MI+1)).0-beta.0"
          echo "Seeding Release-As: v$NEXT"

          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git commit --allow-empty -m "chore: seed prerelease ${NEXT}" -m "Release-As: v${NEXT}"
          git push origin HEAD:${{ inputs.target_branch }}

      # Sanity-check that GITHUB_TOKEN can write (labels API) in this context
      - name: GITHUB_TOKEN write self-test (labels)
        if: always()
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          repo="${{ github.repository }}"
          lbl="rp-selftest-${{ github.run_id }}"
          echo "::group::Create test label"
          gh api -X POST "/repos/$repo/labels" \
            -f name="$lbl" -f color=ededed -f description="release-please token self-test"
          echo "::endgroup::"
          echo "::group::Delete test label"
          gh api -X DELETE "/repos/$repo/labels/$lbl"
          echo "::endgroup::"
      - name: Write last-release-sha into prerelease config
        shell: bash
        env:
          ANCHOR_SHA: ${{ steps.derive_anchor.outputs.anchor_sha }}
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then
            echo "::error::'jq' is required but not found on the runner"; exit 1
          fi
          CFG="release-please-config.prerelease.json"
          if [ ! -f "$CFG" ]; then
            echo "::error::Config file '$CFG' not found on branch"; exit 1
          fi
          tmp=$(mktemp)
          jq --arg sha "$ANCHOR_SHA" '. + { "last-release-sha": $sha }' "$CFG" > "$tmp"
          mv "$tmp" "$CFG"
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add "$CFG"
          git commit -m "chore(${{ steps.guard_validate.outputs.target_safe }}): set prerelease anchor $ANCHOR_SHA" || true
          git push

      - name: Release Please (prerelease)
        uses: googleapis/release-please-action@c2a5a2bd6a758a0937f1ddb1e8950609867ed15c # v4.3.0
        id: rp
        with:
          config-file: release-please-config.prerelease.json
          manifest-file: .release-please-manifest.json
          target-branch: ${{ steps.guard_validate.outputs.target_safe }} # allow input, but default is pre/beta
          skip-github-pull-request: false    # you want the PR
          skip-github-release: true          # <-- prevent create-a-release here
